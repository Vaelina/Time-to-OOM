currhealth = UnitHealth("target")
currtime = GetTime()

if oldtime == nil  						-- If no oldtime value yet
	oldtime = GetTime()	- 5				-- Sets oldtime equal to current time to prevent arithmetic logic
end

if oldhealth == nil						-- If no oldhealth value yet
     oldhealth = UnitHealth(“target”)	-- Sets oldhealth equal to current health to prevent arithmetic issue
end

if oldtime < currtime - 5				-- Rough time check to only run once every 5s
	oldtime = oldtime + 5				-- Brings oldtime up to date for next check
	change = oldhealth - currhealth		-- Sets change equal to change in health
	oldhealth = currhealth				-- Assigns old health to current health for next cycle
--------------------
	do
		local t = {}					-- Initialized array t
		function f(a, b, ...)			-- for function-array, function equals variables of array? dont fully understand this line   - what does function f need to be replaced with, and what stores the value returned
			if b then					-- If array value 2, represented as b, is not nil(has a value)
				return f(a+b, ...)		-- Return sum of array
			else						-- Else, return a (checks for single-value-array)
				return a 
			end
			function average(n)								--incorporate bottom block for average calculation               -what does n need to be replaced with
				if #t == 12									-- If array is full (at max value of 12 stored values), must be nested in 5s timer check
					then table.remove(t, 12)				-- Remove value of t{12}
				end											-- is this necessary? wouldnt it be overwritten anyway next cycle?
				table.insert(t, 1, change)					-- Adds new value to front of list, as held in variable change, moved other values down one
		--		t[#t + 1] = n								-- t[length of t + 1] set to n where n is the value of function average(n)
				average = f(unpack(t, i))					-- a, b = unpack[10,20,30] would return a=10, b=20, but f(unpack(a) where a= {10, 20} returns f(10, 20)     / #t
					i = i or 1
					if t[i] ~= nil then
						return t[i], unpack(t, i+1)
					end
				return average
			end												--shouldnt it be f(unpack(t) /#t)? maybe not, still not following f() functions perfectly
  
		end
	end
	for v=1,12 								--for array values 1 through 12
		do print(average(v)) 				--print the average of the array (needs to be changed from print to return maybe?)
	end	
end	

--------------------  Following code is for overall fight dps
--array1 = change -- is the table.remove(t, 1) this? if not, how do we shift array value? or is that the t[#t + 1] = n line?
totalaverage = ((totalaverage * x) + change) / (x+1)
++x
-------------------   End overall fight dps code
-------------------   Begin defunct code
--if change > .15(totalaverage)
--    if y<12, y=y+1    
--else 
--   if y>0,  y=y-1   -- where z is iterations where 85% check fails
--rollaverage = sum(array) / y
--oldhealth = currhealth
--------------------  End defunct code
-- Array = [4, 7, 6, 5, 0, 0, 0, 0] -- Example array

q = 0                                           -- Minor edit on this block
for x in array
	if x > 0.15 * totalaverage and x > 0 then
		++q
	end
end
average = sumarray / q

-- Testing Branch Push
